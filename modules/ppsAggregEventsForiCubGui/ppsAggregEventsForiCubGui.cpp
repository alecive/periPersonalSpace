/* 
 * Copyright (C) 2016 iCub Facility - Istituto Italiano di Tecnologia
 * Author: Matej Hoffmann
 * email:  matej.hoffmann@iit.it
 * Permission is granted to copy, distribute, and/or modify this program
 * under the terms of the GNU General Public License, version 2 or any
 * later version published by the Free Software Foundation.
 *
 * A copy of the license can be found at
 * http://www.robotcub.org/icub/license/gpl.txt
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
 * Public License for more details
*/

/** 
\defgroup ppsAggregEventsForiCubGui ppsAggregEventsForiCubGui
 
Transforms aggregated tactile/peripersonal space events, as generated by skinEventsAggegator/visuoTactileRF, into a dynContact output that can be sent to/iCubGui/forces and visualized. 
 
\section intro_sec Description 

Transforms aggregated tactile/peripersonal space events, as generated by skinEventsAggegator/visuoTactileRF, into a dynContact output that can be sent to/iCubGui/forces and visualized. 
The input has the following format: aggregated output per skin part with average location, normal and magnitude as extracted from the skin positions files. Maximum 1 vector per skin part; format: (SkinPart_enum x y z o1 o2 o3 magnitude SkinPart_string) (...) - for a maximum of the number of skin parts active.
 
\section lib_sec Libraries 
- YARP.
- skinDynLib 

\section parameters_sec Parameters

--context    \e path
- Where to find the called resource.

--from       \e from
- The name of the .ini file with the configuration parameters.

--name       \e name
- The name of the module.

--verbosity  \e verb
- Verbosity level (default 0). The higher is the verbosity, the more
  information is printed out.

--autoconnect    \e aut
- If to connect automatically to ports. Default not.
 
--tactile \e tac
- if enabled, the tactile aggreg events will be prepared for iCubGui visualization.
 
--pps \e pps
- if enabled, the peripersonal space aggreg events will be prepared for iCubGui visualization.
  
 
\section portsc_sec Ports Created 

- <i> /<name>/skin_events_aggreg:i</i> gets the aggregated skin events as produced by the skinEventsAggegator
- <i> /<name>/pps_events_aggreg:i</i> gets the aggregated pps events as produced by the visuoTactileRF

- <i> /<name>/contacts:o </i>  prepares a dynContact that can be visualized using /iCubGui/forces 
\section tested_os_sec Tested OS
Linux (Ubuntu 12.04)
 
\author Matej Hoffmann
*/ 

#include <cstdio>
#include <string>

#include <yarp/os/all.h>

using namespace std;
using namespace yarp::os;


//********************************************
int main(int argc, char * argv[])
{
    Network yarp;

    ResourceFinder rf;
    rf.setVerbose(false);
    rf.setDefaultContext("periPersonalSpace");
    rf.setDefaultConfigFile("ppsAggregEventsForiCubGui.ini");
    rf.configure(argc,argv);
   
    if (rf.check("help"))
    {    
        yInfo("");
        yInfo("Options:");
        yInfo("   --context     path:  where to find the called resource (default periPersonalSpace).");
        yInfo("   --from        from:  the name of the .ini file (default ppsAggregEventsForiCubGui.ini).");
        yInfo("   --name        name:  the name of the module (default ppsAggregEventsForiCubGui).");
        yInfo("   --verbosity   verbosity:  verbosity level.");
        yInfo("   --autoConnect flag:  if to auto connect the ports or not. Default no.");
        yInfo("   --tactile    flag:  if enabled, the tactile aggreg events will be prepared for iCubGui visualization.");
        yInfo("   --pps       flag:  if enabled, the peripersonal space aggreg events will be prepared for iCubGui visualization.");
        yInfo("");
        return 0;
    }

    string context=rf.check("context",Value("periPersonalSpace")).asString(); 
    string from=rf.check("from",Value("ppsAggregEventsForiCubGui.ini")).asString();
    string name=rf.check("name",Value("ppsAggregEventsForiCubGui")).asString();
    int verbosity = rf.check("verbosity",Value(0)).asInt();
    bool autoconnect=rf.check("autoconnect",Value("off")).asString()=="on"?true:false; // on | off
    bool tactile=rf.check("tactile",Value("on")).asString()=="on"?true:false; // on | off
    bool pps=rf.check("pps",Value("on")).asString()=="on"?true:false; // on | off
       
    yInfo("Starting with the following parameters: \n context: %s \n from: %s \n name: %s \n verbosity: %d \n autoconect : %d \n tactile: %d \n pps: %d \n",context.c_str(),from.c_str(),name.c_str(),verbosity,autoconnect,tactile,pps);
    
    
    if (!yarp.checkNetwork())
    {
        yError("No Network!!!");
        return -1;
    }
   
   
   
   
    
    
}

